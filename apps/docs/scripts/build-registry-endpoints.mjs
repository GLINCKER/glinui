import {
  mkdirSync,
  readFileSync,
  readdirSync,
  rmSync,
  writeFileSync
} from "node:fs"
import { dirname, join, resolve } from "node:path"
import { fileURLToPath } from "node:url"
import ts from "typescript"
import vm from "node:vm"

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)
const root = resolve(__dirname, "..", "..", "..")

const registrySourceFile = join(root, "packages", "registry", "src", "index.ts")
const componentsDir = join(root, "packages", "ui", "src", "components")
const endpointsRoot = join(root, "apps", "docs", "public", "r")
const itemsDir = join(endpointsRoot, "items")
const indexFile = join(endpointsRoot, "index.json")
const schemaFile = join(endpointsRoot, "schema.json")

function loadRegistryItems() {
  const source = readFileSync(registrySourceFile, "utf8")
  const transpiled = ts.transpileModule(source, {
    compilerOptions: {
      target: ts.ScriptTarget.ES2020,
      module: ts.ModuleKind.CommonJS
    }
  }).outputText

  const module = { exports: {} }
  const context = vm.createContext({
    module,
    exports: module.exports
  })

  vm.runInContext(transpiled, context, { filename: registrySourceFile })
  const items = module.exports.baseRegistry

  if (!Array.isArray(items)) {
    throw new Error("Unable to read baseRegistry from packages/registry/src/index.ts")
  }

  return items
}

function toPrettyJson(value) {
  return `${JSON.stringify(value, null, 2)}\n`
}

function writeIfChanged(filePath, value) {
  const next = toPrettyJson(value)
  try {
    const prev = readFileSync(filePath, "utf8")
    if (prev === next) {
      return false
    }
  } catch {
    // File does not exist yet.
  }
  writeFileSync(filePath, next, "utf8")
  return true
}

function cleanupStaleItemFiles(validNames) {
  const entries = readdirSync(itemsDir, { withFileTypes: true })
  for (const entry of entries) {
    if (!entry.isFile() || !entry.name.endsWith(".json")) {
      continue
    }
    const name = entry.name.replace(/\.json$/, "")
    if (!validNames.has(name)) {
      rmSync(join(itemsDir, entry.name))
    }
  }
}

function getComponentSourcePath(name) {
  return join(componentsDir, `${name}.tsx`)
}

function buildSchemaPayload() {
  return {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "https://glinui.com/r/schema.json",
    title: "Glin UI Config",
    description: "Configuration file generated by the glinui CLI.",
    type: "object",
    additionalProperties: false,
    required: ["$schema", "style", "tailwind", "aliases"],
    properties: {
      $schema: {
        type: "string",
        format: "uri"
      },
      style: {
        type: "string",
        enum: ["default"]
      },
      tailwind: {
        type: "object",
        additionalProperties: false,
        required: ["css"],
        properties: {
          css: {
            type: "string",
            minLength: 1
          }
        }
      },
      aliases: {
        type: "object",
        additionalProperties: false,
        required: ["components", "utils"],
        properties: {
          components: {
            type: "string",
            minLength: 1
          },
          utils: {
            type: "string",
            minLength: 1
          }
        }
      }
    }
  }
}

function build() {
  const items = loadRegistryItems()
  const sortedItems = [...items].sort((a, b) =>
    String(a.name).localeCompare(String(b.name))
  )

  mkdirSync(endpointsRoot, { recursive: true })
  mkdirSync(itemsDir, { recursive: true })

  let changed = 0
  const validNames = new Set()

  const indexPayload = sortedItems.map((item) => ({
    name: String(item.name),
    type: item.type === "signature" ? "signature" : "primitive",
    description: String(item.description ?? ""),
    dependencies: Array.isArray(item.dependencies)
      ? item.dependencies.map((dep) => String(dep))
      : [],
    registryDependencies: Array.isArray(item.registryDependencies)
      ? item.registryDependencies.map((dep) => String(dep))
      : []
  }))

  changed += Number(writeIfChanged(indexFile, indexPayload))
  changed += Number(writeIfChanged(schemaFile, buildSchemaPayload()))

  for (const item of sortedItems) {
    const name = String(item.name)
    validNames.add(name)

    const componentSourcePath = getComponentSourcePath(name)
    let componentSource
    try {
      componentSource = readFileSync(componentSourcePath, "utf8")
    } catch {
      throw new Error(
        `Missing component source for "${name}" at packages/ui/src/components/${name}.tsx`
      )
    }

    const itemPayload = {
      name,
      type: item.type === "signature" ? "signature" : "primitive",
      description: String(item.description ?? ""),
      dependencies: Array.isArray(item.dependencies)
        ? item.dependencies.map((dep) => String(dep))
        : [],
      files: [
        {
          path: `packages/ui/src/components/${name}.tsx`,
          content: componentSource
        }
      ]
    }

    changed += Number(writeIfChanged(join(itemsDir, `${name}.json`), itemPayload))
  }

  cleanupStaleItemFiles(validNames)

  // eslint-disable-next-line no-console
  console.log(
    `built registry endpoints (${sortedItems.length} items, ${changed} files changed) -> ${endpointsRoot}`
  )
}

build()
